# CMPT 332 -- Fall 2017
# Assignment 1
# Derek Perrin 		dmp450 11050915
# Dominic McKeith 	dom258 11184543

# Part C Design Documentation

### HEADS UP: WE DID THE BONUS. DETAILS BELOW ###

# Pseudocode below:

# We set the following constants to low values to make testing easier so we
# could call add_list_memory and add_node_memory multiple times without having
# massive for loops.

const MIN_LISTS = 2
const MIN_NODES = 8

LIST** list_mem
NODE** node_mem

# the following four variables are used to keep track of how much to grow the
# size of the list and node memory pools by. list_mem_blocks increments by 1
# every time a grow is called, list_mem_size doubles every time a grow is 
# called. list_mem_blocks essentially grows the "outer shell" of the memory
# array, while list_mem_size grows the inner amount of available lists.

int list_mem_blocks
int list_mem_size

int node_mem_blocks
int node_mem_size

struct NODE {
    NODE* next
    NODE* prev
    void* data
}

struct LIST {
    NODE* curr
    NODE* head
    NODE* tail
    int size
    LIST next
}

# We create a queue to keep track of free lists and nodes. This is the reason
# we have a 'next' member in our LIST implementation. All lists point to the
# next free list. The last list points to NULL. A 'free' pointer points to the
# head of the list at all times. To give memory back to the list pool, the 
# 'next' member is changed to point to the head of the list pool, and 'free'
# points to the list being freed. It's a really slick implementation.

# We included extra files called list_alloc.c and list_alloc.h. These contain
# functions used to grow our memory, and in phase 3 will be used to shrink
# our memory. We made a separate file because it made things a bit cleaner
# inside of our list_adders and other files, since they are really only used
# to grow the memory.

# list_alloc
add_list_memory()
    # grows the list memory by doubling it when more memory is needed.
    # On the first call, the initial list memory is set to MIN_LISTS.
    # We use realloc to grow the memory. The first call of realloc acts the same
    # as malloc according to the man page; this is when realloc is passed a NULL
    # pointer. The basic design is having our list memory pool as a pointer to
    # an array of LIST pointers. When more memory is needed, we realloc the 
    # array of pointers. This way, any pointers that were previously returned
    # to the user are still retained. The only way we found to make this
    # function fail is to use up all of the memory on the computer. Regardless,
    # the function will return -1 if anything fails inside.

add_node_memory()
    # This code is exactly the same as add_list_memory, but the variable names
    # say node instead of list.

request_list()
    # Returns a list to the user. If no lists are available because memory is
    # full, then a call is made to add_list_memory() and then a free list is
    # returned.

request_node()
    # This code is exactly the same as request_list, but the variable names
    # say node instead of list.

release_list()
    # this is called to release a list back to the memory pool. If the total
    # used lists are less than half of available lists, a call to
    # shrink_list_memory() is made to halve the size of the available memory.

release_node()
    # This code is exactly the same as release_list, but the variable names
    # say node instead of list.

shrink_list_memory()
    # We have no idea how we'll implement this yet. It shrinks the available
    # memory to be half of the current available memory.

shrink_node_memory()
    # We have no idea how we'll implement this yet. It shrinks the available
    # memory to be half of the current available memory.
    

LIST* ListCreate()
    LIST* newList = requestList();
    if (newList == NULL)
        # something bad went wrong because it should have grown
        return NULL
    newList->head = NULL
    newList->tail = NULL
    newList->curr = NULL
    newList->next = NULL
    newList->size = 0
    return newList

int ListCount()
    return list.size

void* ListFirst()
    return list.head

void* ListLast()
    return list.tail

void* ListNext()
    list.curr = list.curr.next
    return list.curr.data

void* ListPrev()
    list.curr = list.curr.prev
    return list.curr.data

void* ListCurr()
    return list.curr

int ListAdd()
    pop from node_pool
    adjust pointers to accommodate it
    insert item in list.curr

int ListInsert()
    Same as ListAdd(), but backwards

int ListAppend()
    pop from node_pool
    adjust pointers of tail for new node
    insert item in last node
    return 1

int ListPrepend()
    same as ListAppend, but adjust head

void* ListRemove()
    list.curr.next.prev = list.curr.prev
    list.curr = list.curr.next
    list.curr.prev.next = list.curr
    return list.curr.item

void ListConcat()
    list1.tail.next = list2.head
    list2.head.prev = list1.tail
    list1.tail = list2.tail
    list2 and its members are NULL
    push(list2) to list_stack

void ListFree(list, freeitem)
    for (node in list)
        freeitem(node.item)
        node.item = NULL
        push(node) node_stack
    nullify(list members)
    release_list(list)

void* ListTrim
    rNode = list.tail
    list.tail = list.tail.prev
    list.tail.next = NULL
    return rNode

void* ListSearch()
    for (node in list)
        if (comparator(item, comparisonArg))
            list.curr = node
            return list.curr.item
    return 0
